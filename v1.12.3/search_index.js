var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"OffsetArray\nOffsetVector\nOffsetMatrix\nOffsetArrays.Origin\nOffsetArrays.IdOffsetRange\nOffsetArrays.no_offset_view\nOffsetArrays.AxisConversionStyle\nOffsetArrays.center\nOffsetArrays.centered","category":"page"},{"location":"reference/#OffsetArrays.OffsetArray","page":"Reference","title":"OffsetArrays.OffsetArray","text":"OffsetArray(A, indices...)\n\nReturn an AbstractArray that shares element type and size with the first argument but uses the supplied indices to infer its axes. If all the indices are AbstractUnitRanges then these are directly used as the axis span along each dimension. Refer to the examples below for other permissible types.\n\nAlternatively it's possible to specify the coordinates of one corner of the array and have the axes be computed automatically from the size of A. This constructor makes it convenient to shift to an arbitrary starting index along each axis, for example to a zero-based indexing scheme followed by arrays in languages such as C and Python. See Origin and the examples below for this usage.\n\nExample: offsets\n\nThere are two types of indices: integers and ranges-like types.\n\nIntegers are recognized as offsets, where 0 means no offsets are applied:\n\njulia> A = OffsetArray(reshape(1:6, 2, 3), -1, -2)\n2×3 OffsetArray(reshape(::UnitRange{Int64}, 2, 3), 0:1, -1:1) with eltype Int64 with indices 0:1×-1:1:\n 1  3  5\n 2  4  6\n\njulia> A[0, 1]\n5\n\nExamples of range-like types are: UnitRange (e.g, -1:2), CartesianIndices, and Colon() (or concisely :). A UnitRange specifies the axis span along one particular dimension, CartesianIndices specify the axis spans along multiple dimensions, and a Colon is a placeholder that specifies that the OffsetArray shares its axis with its parent along that dimension.\n\njulia> OffsetArray(reshape(1:6, 2, 3), 0:1, -1:1)\n2×3 OffsetArray(reshape(::UnitRange{Int64}, 2, 3), 0:1, -1:1) with eltype Int64 with indices 0:1×-1:1:\n 1  3  5\n 2  4  6\n\njulia> OffsetArray(reshape(1:6, 2, 3), :, -1:1) # : as a placeholder to indicate that no offset is to be applied to the first dimension\n2×3 OffsetArray(reshape(::UnitRange{Int64}, 2, 3), 1:2, -1:1) with eltype Int64 with indices 1:2×-1:1:\n 1  3  5\n 2  4  6\n\nUse CartesianIndices to specify the coordinates of two diagonally opposite corners:\n\njulia> OffsetArray(reshape(1:6, 2, 3), CartesianIndex(0, -1):CartesianIndex(1, 1))\n2×3 OffsetArray(reshape(::UnitRange{Int64}, 2, 3), 0:1, -1:1) with eltype Int64 with indices 0:1×-1:1:\n 1  3  5\n 2  4  6\n\nIntegers and range-like types may not be combined in the same call:\n\njulia> OffsetArray(reshape(1:6, 2, 3), 0, -1:1)\nERROR: [...]\n\nExample: origin\n\nOffsetArrays.Origin may be used to specify the origin of the OffsetArray. The term origin here refers to the corner with the lowest values of coordinates, such as the left edge for an AbstractVector, the bottom left corner for an AbstractMatrix and so on. The coordinates of the origin sets the starting index of the array along each dimension.\n\njulia> a = [1 2; 3 4];\n\njulia> OffsetArray(a, OffsetArrays.Origin(0, 1))\n2×2 OffsetArray(::Matrix{Int64}, 0:1, 1:2) with eltype Int64 with indices 0:1×1:2:\n 1  2\n 3  4\n\njulia> OffsetArray(a, OffsetArrays.Origin(0)) # set the origin to zero along each dimension\n2×2 OffsetArray(::Matrix{Int64}, 0:1, 0:1) with eltype Int64 with indices 0:1×0:1:\n 1  2\n 3  4\n\n\n\n\n\n","category":"type"},{"location":"reference/#OffsetArrays.OffsetVector","page":"Reference","title":"OffsetArrays.OffsetVector","text":"OffsetVector(v, index)\n\nType alias and convenience constructor for one-dimensional OffsetArrays.\n\n\n\n\n\n","category":"type"},{"location":"reference/#OffsetArrays.OffsetMatrix","page":"Reference","title":"OffsetArrays.OffsetMatrix","text":"OffsetMatrix(A, index1, index2)\n\nType alias and convenience constructor for two-dimensional OffsetArrays.\n\n\n\n\n\n","category":"type"},{"location":"reference/#OffsetArrays.Origin","page":"Reference","title":"OffsetArrays.Origin","text":"Origin(indices...)\nOrigin(origin::Tuple)\nOrigin(origin::CartesianIndex)\n\nA helper type to construct OffsetArray with a given origin. This is not exported.\n\nThe origin of an array is defined as the tuple of the first index along each axis, i.e., first.(axes(A)).\n\nExample\n\njulia> a = [1 2; 3 4];\n\njulia> using OffsetArrays: Origin\n\njulia> OffsetArray(a, Origin(0, 1))\n2×2 OffsetArray(::Matrix{Int64}, 0:1, 1:2) with eltype Int64 with indices 0:1×1:2:\n 1  2\n 3  4\n\njulia> OffsetArray(a, Origin(0)) # short notation for `Origin(0, 0)`\n2×2 OffsetArray(::Matrix{Int64}, 0:1, 0:1) with eltype Int64 with indices 0:1×0:1:\n 1  2\n 3  4\n\nAn Origin object is callable, and it may shift the origin of an array to the specified point.\n\njulia> b = Origin(0)(a) # shift the origin of the array to (0,0)\n2×2 OffsetArray(::Matrix{Int64}, 0:1, 0:1) with eltype Int64 with indices 0:1×0:1:\n 1  2\n 3  4\n\nThe type Origin, when called with an AbstractArray as the argument, will return an instance corresponding ot the origin of the array.\n\njulia> origin_b = Origin(b) # retrieve the origin of the array as an Origin instance\nOrigin(0, 0)\n\njulia> origin_b(ones(2,2)) # shift the origin of another array to that of b, in this case to (0,0)\n2×2 OffsetArray(::Matrix{Float64}, 0:1, 0:1) with eltype Float64 with indices 0:1×0:1:\n 1.0  1.0\n 1.0  1.0\n\ntip: Tip\nOne may broadcast an Origin instance over multiple arrays to shift them all to the same origin.julia> using OffsetArrays: Origin\n\njulia> a = [1 2; 3 4]; # origin at (1,1)\n\njulia> b = Origin(2,3)(a); # origin at (2,3)\n\njulia> c = Origin(4)(a); # origin at (4,4)\n\njulia> ao, bo, co = Origin(0).((a, b, c)); # shift all origins to (0,0)\n\njulia> first.(axes(ao)) == first.(axes(bo)) == first.(axes(co)) == (0,0)\ntrue\n\njulia> ao, bo, co = Origin(b).((a, b, c)); # shift all origins to that of b\n\njulia> first.(axes(ao)) == first.(axes(bo)) == first.(axes(co)) == (2,3)\ntrue\n\njulia> ao, bo, co = OffsetArray.((a, b, c), Origin(b)); # another way to do the same\n\njulia> first.(axes(ao)) == first.(axes(bo)) == first.(axes(co)) == (2,3)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"reference/#OffsetArrays.IdOffsetRange","page":"Reference","title":"OffsetArrays.IdOffsetRange","text":"ro = IdOffsetRange(r::AbstractUnitRange, offset=0)\n\nConstruct an \"identity offset range\". Numerically, collect(ro) == collect(r) .+ offset, with the additional property that axes(ro, 1) = axes(r, 1) .+ offset. When r starts at 1, then ro[i] == i and even ro[ro] == ro, i.e., it's the \"identity,\" which is the origin of the \"Id\" in IdOffsetRange.\n\nExamples\n\nThe most common case is shifting a range that starts at 1 (either 1:n or Base.OneTo(n)):\n\njulia> using OffsetArrays: IdOffsetRange\n\njulia> ro = IdOffsetRange(1:3, -2)\nIdOffsetRange(values=-1:1, indices=-1:1)\n\njulia> axes(ro, 1)\nIdOffsetRange(values=-1:1, indices=-1:1)\n\njulia> ro[-1]\n-1\n\njulia> ro[3]\nERROR: BoundsError: attempt to access 3-element IdOffsetRange{Int64, UnitRange{Int64}} with indices -1:1 at index [3]\n\nIf the range doesn't start at 1, the values may be different from the indices:\n\njulia> ro = IdOffsetRange(11:13, -2)\nIdOffsetRange(values=9:11, indices=-1:1)\n\njulia> axes(ro, 1)     # 11:13 is indexed by 1:3, and the offset is also applied to the axes\nIdOffsetRange(values=-1:1, indices=-1:1)\n\njulia> ro[-1]\n9\n\njulia> ro[3]\nERROR: BoundsError: attempt to access 3-element IdOffsetRange{Int64, UnitRange{Int64}} with indices -1:1 at index [3]\n\nExtended help\n\nConstruction/coercion preserves the (shifted) values of the input range, but may modify the indices if required by the specified types. For example,\n\nr = OffsetArrays.IdOffsetRange{Int,UnitRange{Int}}(3:4)\n\nhas r[1] == 3 and r[2] == 4, whereas\n\nr = OffsetArrays.IdOffsetRange{Int,Base.OneTo{Int}}(3:4)\n\nhas r[3] == 3 and r[4] == 4, and r[1] would throw a BoundsError. In this latter case, a shift in the axes was needed because Base.OneTo ranges must start with value 1.\n\nwarning: Warning\nIn the future, conversion will preserve both the values and the indices, throwing an error when this is not achievable. For instance,r = convert(OffsetArrays.IdOffsetRange{Int,UnitRange{Int}}, 3:4)has r[1] == 3 and r[2] == 4 and would satisfy r == 3:4, whereasjulia> convert(OffsetArrays.IdOffsetRange{Int,Base.OneTo{Int}}, 3:4)    # future behavior, not present behavior\nERROR: ArgumentError: first element must be 1, got 3where the error will arise because the result could not have the same axes as the input.An important corollary is that typeof(r1)(r2) and oftype(r1, r2) will behave differently: the first coerces r2 to be of the type of r1, whereas the second converts. Developers are urged to future-proof their code by choosing the behavior appropriate for each usage.\n\n\n\n\n\n","category":"type"},{"location":"reference/#OffsetArrays.no_offset_view","page":"Reference","title":"OffsetArrays.no_offset_view","text":"no_offset_view(A)\n\nReturn an AbstractArray that shares structure and underlying data with the argument, but uses 1-based indexing. May just return the argument when applicable. Not exported.\n\nThe default implementation uses OffsetArrays, but other types should use something more specific to remove a level of indirection when applicable.\n\njulia> A = [1 3 5; 2 4 6];\n\njulia> O = OffsetArray(A, 0:1, -1:1)\n2×3 OffsetArray(::Matrix{Int64}, 0:1, -1:1) with eltype Int64 with indices 0:1×-1:1:\n 1  3  5\n 2  4  6\n\njulia> OffsetArrays.no_offset_view(O)[1,1] = -9\n-9\n\njulia> A\n2×3 Matrix{Int64}:\n -9  3  5\n  2  4  6\n\n\n\n\n\n","category":"function"},{"location":"reference/#OffsetArrays.AxisConversionStyle","page":"Reference","title":"OffsetArrays.AxisConversionStyle","text":"OffsetArrays.AxisConversionStyle(typeof(indices))\n\nAxisConversionStyle declares if indices should be converted to a single AbstractUnitRange{Int} or to a Tuple{Vararg{AbstractUnitRange{Int}}} while flattening custom types into indices. This method is called after to_indices(A::Array, axes(A), indices) to provide further information in case to_indices does not return a Tuple of AbstractUnitRange{Int}.\n\nCustom index types should extend AxisConversionStyle and return either OffsetArray.SingleRange(), which is the default, or OffsetArray.TupleOfRanges(). In the former case, the type T should define Base.convert(::Type{AbstractUnitRange{Int}}, ::T), whereas in the latter it should define Base.convert(::Type{Tuple{Vararg{AbstractUnitRange{Int}}}}, ::T).\n\nAn example of the latter is CartesianIndices, which is converted to a Tuple of AbstractUnitRange{Int} while flattening the indices.\n\nExample\n\njulia> struct NTupleOfUnitRanges{N}\n           x ::NTuple{N, UnitRange{Int}}\n       end\n\njulia> Base.to_indices(A, inds, t::Tuple{NTupleOfUnitRanges{N}}) where {N} = t;\n\njulia> OffsetArrays.AxisConversionStyle(::Type{NTupleOfUnitRanges{N}}) where {N} = OffsetArrays.TupleOfRanges();\n\njulia> Base.convert(::Type{Tuple{Vararg{AbstractUnitRange{Int}}}}, t::NTupleOfUnitRanges) = t.x;\n\njulia> a = zeros(3, 3);\n\njulia> inds = NTupleOfUnitRanges((3:5, 2:4));\n\njulia> oa = OffsetArray(a, inds);\n\njulia> axes(oa, 1) == 3:5\ntrue\n\njulia> axes(oa, 2) == 2:4\ntrue\n\n\n\n\n\n","category":"type"},{"location":"reference/#OffsetArrays.center","page":"Reference","title":"OffsetArrays.center","text":"center(A, [r::RoundingMode=RoundDown])::Dims\n\nReturn the center coordinate of given array A. If size(A, k) is even, a rounding procedure will be applied with mode r.\n\ncompat: OffsetArrays 1.9\nThis method requires at least OffsetArrays 1.9.\n\nExamples\n\njulia> A = reshape(collect(1:9), 3, 3)\n3×3 Matrix{Int64}:\n 1  4  7\n 2  5  8\n 3  6  9\n\njulia> c = OffsetArrays.center(A)\n(2, 2)\n\njulia> A[c...]\n5\n\njulia> Ao = OffsetArray(A, -2, -2); # axes (-1:1, -1:1)\n\njulia> c = OffsetArrays.center(Ao)\n(0, 0)\n\njulia> Ao[c...]\n5\n\nTo shift the center coordinate of the given array to (0, 0, ...), you can use centered.\n\n\n\n\n\n","category":"function"},{"location":"reference/#OffsetArrays.centered","page":"Reference","title":"OffsetArrays.centered","text":"centered(A, cp=center(A)) -> Ao\n\nShift the center coordinate/point cp of array A to (0, 0, ..., 0). Internally, this is equivalent to OffsetArray(A, .-cp).\n\ncompat: OffsetArrays 1.9\nThis method requires at least OffsetArrays 1.9.\n\nExamples\n\njulia> A = reshape(collect(1:9), 3, 3)\n3×3 Matrix{Int64}:\n 1  4  7\n 2  5  8\n 3  6  9\n\njulia> Ao = OffsetArrays.centered(A); # axes (-1:1, -1:1)\n\njulia> Ao[0, 0]\n5\n\njulia> Ao = OffsetArray(A, OffsetArrays.Origin(0)); # axes (0:2, 0:2)\n\njulia> Aoo = OffsetArrays.centered(Ao); # axes (-1:1, -1:1)\n\njulia> Aoo[0, 0]\n5\n\nUsers are allowed to pass cp to change how \"center point\" is interpreted, but the meaning of the output array should be reinterpreted as well. For instance, if cp = map(last, axes(A)) then this function no longer shifts the center point but instead the bottom-right point to (0, 0, ..., 0). A commonly usage of cp is to change the rounding behavior when the array is of even size at some dimension:\n\njulia> A = reshape(collect(1:4), 2, 2) # Ideally the center should be (1.5, 1.5) but OffsetArrays only support integer offsets\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n\njulia> OffsetArrays.centered(A, OffsetArrays.center(A, RoundUp)) # set (2, 2) as the center point\n2×2 OffsetArray(::Matrix{Int64}, -1:0, -1:0) with eltype Int64 with indices -1:0×-1:0:\n 1  3\n 2  4\n\njulia> OffsetArrays.centered(A, OffsetArrays.center(A, RoundDown)) # set (1, 1) as the center point\n2×2 OffsetArray(::Matrix{Int64}, 0:1, 0:1) with eltype Int64 with indices 0:1×0:1:\n 1  3\n 2  4\n\nSee also center.\n\n\n\n\n\n","category":"function"},{"location":"#OffsetArrays.jl","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"","category":"section"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"OffsetArrays provides Julia users with arrays that have arbitrary indices, similar to those found in some other programming languages like Fortran. Below is the basic usage found in the README, followed by a couple of short examples illustrating circumstances in which OffsetArrays can be useful. For a lengthier discussion, see this blog post.","category":"page"},{"location":"#Usage","page":"OffsetArrays.jl","title":"Usage","text":"","category":"section"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"You can construct such arrays as follows:","category":"page"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"OA = OffsetArray(A, axis1, axis2, ...)","category":"page"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"where you want OA to have axes (axis1, axis2, ...) and be indexed by values that fall within these axis ranges.","category":"page"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"using OffsetArrays\n\nA = Float64.(reshape(1:15, 3, 5))\n\nOA = OffsetArray(A, -1:1, 0:4) # OA will have axes (-1:1, 0:4)\n\nOA = OffsetArray(A, CartesianIndex(-1, 0):CartesianIndex(1, 4))\n\nOA[-1,0], OA[1,4]","category":"page"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"You could also pass integers as offsets, where 0 means no offsets are applied:","category":"page"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"OA = OffsetArray(A, -2, -1)","category":"page"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"When you create a new OffsetArray on the top of another OffsetArray, the offsets are accumulated:","category":"page"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"OOA = OffsetArray(OA, 2, 1)","category":"page"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"For the special cases that you want to compensate the offset back to the ordinary 1-based array, you can use OffsetArrays.no_offset_view(A). Furthermore, you could use Base.require_one_based_indexing if you want to ensure the array does not have offsets.","category":"page"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"OffsetArrays.no_offset_view(OA)\n\nBase.require_one_based_indexing(ans)\n\nBase.require_one_based_indexing(OA)","category":"page"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"OffsetArrays.Origin can be convenient if you want to directly specify the origin of the output OffsetArray, it will automatically compute the corresponding offsets. For example:","category":"page"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"OffsetArray(A, OffsetArrays.Origin(-1, -1))\nOffsetArray(OA, OffsetArrays.Origin(-1, -1))","category":"page"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"An equivalent — but possibly more convenient — way to specify the origin of an array is","category":"page"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"OffsetArrays.Origin(-1, -1)(A)","category":"page"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"Sometimes, it will be convenient to shift the center coordinate of the given array to (0, 0, ...), OffsetArrays.centered is a helper for this very purpose:","category":"page"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"Ao = OffsetArrays.centered(A)\nAo[0, 0] == 8.0","category":"page"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"and OffsetArrays.center tells you the center coordinate of given array:","category":"page"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"c = OffsetArrays.center(A)\nA[c...] == 8.0","category":"page"},{"location":"#Example:-Relativistic-Notation","page":"OffsetArrays.jl","title":"Example: Relativistic Notation","text":"","category":"section"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"Suppose we have a position vector r = [:x, :y, :z] which is naturally one-based, ie. r[1] == :x, r[2] == :y,  r[3] == :z and we also want to construct a relativistic position vector which includes time as the 0th component. This can be done with OffsetArrays like","category":"page"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"julia> r = [:x, :y, :z];\n\njulia> x = OffsetVector([:t, r...], 0:3)\n4-element OffsetArray(::Vector{Symbol}, 0:3) with eltype Symbol with indices 0:3:\n :t\n :x\n :y\n :z\n\njulia> x[0]\n:t\n\njulia> x[1:3]\n3-element Vector{Symbol}:\n :x\n :y\n :z","category":"page"},{"location":"#Example:-Polynomials","page":"OffsetArrays.jl","title":"Example: Polynomials","text":"","category":"section"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"Suppose one wants to represent the Laurent polynomial","category":"page"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"6x + 5 - 2*x + 3*x^2 + x^3","category":"page"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"The coefficients of this polynomial are a naturally -1 based list, since the nth element of the list (counting from -1) 6, 5, -2, 3, 1 is the coefficient corresponding to the nth power of x. This Laurent polynomial can be evaluated at say x = 2 as follows.","category":"page"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"julia> coeffs = OffsetVector([6, 5, -2, 3, 1], -1:3)\n5-element OffsetArray(::Vector{Int64}, -1:3) with eltype Int64 with indices -1:3:\n  6\n  5\n -2\n  3\n  1\n\njulia> polynomial(x, coeffs) = sum(coeffs[n]*x^n for n in eachindex(coeffs))\npolynomial (generic function with 1 method)\n\njulia> polynomial(2.0, coeffs)\n24.0","category":"page"},{"location":"","page":"OffsetArrays.jl","title":"OffsetArrays.jl","text":"Notice our use of the eachindex function which does not assume that the given array starts at 1.","category":"page"},{"location":"internals/#For-developers","page":"For developers","title":"For developers","text":"","category":"section"},{"location":"internals/","page":"For developers","title":"For developers","text":"Writing code that supports OffsetArrays is generally fairly straightforward. The majority of cases can be handled with these tips:","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"replace many uses of size with axes\nreplace 1:length(A) with eachindex(A), or if you need an integer index with LinearIndices(A)\nreplace explicit allocations like Array{Int}(undef, size(B)) with similar(Array{Int}, axes(B))","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"More information can be found in Julia's developer documentation. The most subtle issues tend to arise around the axes, and further detail specific to OffsetArrays.jl follows below.","category":"page"},{"location":"internals/#Internals","page":"For developers","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"For developers","title":"For developers","text":"How does OffsetArrays work? The fundamental principle is very simple: an OffsetArray is just a wrapper around a \"parent\" array, together with an index offset:","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"julia> oa = OffsetArray([1 2; 3 4], 0:1, 5:6)\n2×2 OffsetArray(::Matrix{Int64}, 0:1, 5:6) with eltype Int64 with indices 0:1×5:6:\n 1  2\n 3  4\n\njulia> parent(oa)\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> oa.offsets\n(-1, 4)","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"So parent(oa) is the original array we constructed it with, and oa.offsets is a tuple, each entry encoding the index-shift to be applied along the corresponding axis. When you index oa[i,j], it \"translates\" the i,j indexes back to the parent array's indexes and then returns the value in the parent.","category":"page"},{"location":"internals/#The-axes-of-OffsetArrays","page":"For developers","title":"The axes of OffsetArrays","text":"","category":"section"},{"location":"internals/","page":"For developers","title":"For developers","text":"The internal of offset computing is achieved by IdOffsetRange type:","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"julia> ax = axes(oa, 2)\nOffsetArrays.IdOffsetRange(values=5:6, indices=5:6)","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"This has a similar design to Base.IdentityUnitRange that ax[x] == x always holds.","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"julia> ax[5]\n5\njulia> ax[1]\nERROR: BoundsError: attempt to access 2-element OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}} with indices 5:6 at index [1]\n[...]","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"This property makes sure that they tend to be their own axes:","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"julia> axes(ax)\n(OffsetArrays.IdOffsetRange(values=5:6, indices=5:6),)\n\njulia> axes(ax[ax])\n(OffsetArrays.IdOffsetRange(values=5:6, indices=5:6),)","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"This example of indexing is idempotent. This is a useful characteristic for ensuring the \"fundamental axiom\" of generalized indexing, that a[ax][i] == a[ax[i]]:","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"julia> oa2 = OffsetArray([5, 10, 15, 20], 0:3)\n4-element OffsetArray(::Vector{Int64}, 0:3) with eltype Int64 with indices 0:3:\n  5\n 10\n 15\n 20\n\njulia> ax2 = axes(oa2, 1)\nOffsetArrays.IdOffsetRange(values=0:3, indices=0:3)\n\njulia> oa2[2]\n15\n\njulia> oa2[ax2][2]\n15\n\njulia> oa2[ax2[2]]\n15","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"IdOffsetRanges apply the offset both to the values and the indices of the range, and otherwise preserve the parent range.","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"warning: Warning\nThere are circumstances where constructing a specific type of IdOffsetRange cannot be supported without changing the axes of the range (see OffsetArrays.IdOffsetRange.) In the future, this package will distinguish between construction  and conversion:construction (aka, coercion) will always succeed, even if it has to change the axes of the result (Examples: RangeType(rng), typeof(rng1)(rng2))\nconversion will succeed only if it can preserve both the values and the axes (Examples: convert(RangeType, rng), oftype(rng1, rng2))While these behave equivalently now (conversion currently performs coercion), developers are encouraged to \"future-proof\" their code by choosing the behavior appropriate for each usage.","category":"page"},{"location":"internals/#Wrapping-other-offset-array-types","page":"For developers","title":"Wrapping other offset array types","text":"","category":"section"},{"location":"internals/","page":"For developers","title":"For developers","text":"An OffsetArray may wrap any subtype of AbstractArray, including ones that do not use 1-based indexing. Such arrays however need to satisfy the fundamental axiom of idempotent indexing for things to work correctly. In other words, an axis of an offset array needs to have the same values as its own axis. This property is built into OffsetArrays if the parent uses 1-based indexing, but it's up to the user to ensure the correctness in case a type is to be wrapped that uses offset indices.","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"We demonstrate this through an example by creating a custom 0-based range type that we wrap in an OffsetArray:","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"julia> struct ZeroBasedRange{T,A<:AbstractRange{T}} <: AbstractRange{T}\n           a :: A\n           function ZeroBasedRange(a::AbstractRange{T}) where {T}\n               @assert !Base.has_offset_axes(a)\n               new{T, typeof(a)}(a)\n           end\n       end;\n\njulia> Base.parent(A::ZeroBasedRange) = A.a;\n\njulia> Base.first(A::ZeroBasedRange) = first(A.a);\n\njulia> Base.length(A::ZeroBasedRange) = length(A.a);\n\njulia> Base.last(A::ZeroBasedRange) = last(A.a);\n\njulia> Base.size(A::ZeroBasedRange) = size(A.a);\n\njulia> Base.axes(A::ZeroBasedRange) = map(x -> 0:x-1, size(A.a));\n\njulia> Base.getindex(A::ZeroBasedRange, i::Int) = A.a[i + 1];\n\njulia> Base.step(A::ZeroBasedRange) = step(A.a);\n\njulia> function Base.show(io::IO, A::ZeroBasedRange)\n           show(io, A.a)\n           print(io, \" with indices $(axes(A,1))\")\n       end;","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"This definition of a ZeroBasedRange appears to have the correct indices, for example:","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"julia> z = ZeroBasedRange(1:4)\n1:4 with indices 0:3\n\njulia> z[0]\n1\n\njulia> z[3]\n4","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"However this does not use idempotent indexing, as the axis of a ZeroBasedRange is not its own axis.","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"julia> axes(z, 1)\n0:3\n\njulia> axes(axes(z, 1), 1)\nBase.OneTo(4)","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"This will lead to complications in certain functions –- for example LinearIndices –- that tend to implictly assume idempotent indexing. In this case the LinearIndices of z will not match its axis.","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"julia> LinearIndices(z)\n4-element LinearIndices{1, Tuple{UnitRange{Int64}}}:\n 1\n 2\n 3\n 4","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"Wrapping such a type in an OffsetArray might lead to unexpected bugs.","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"julia> zo = OffsetArray(z, 1);\n\njulia> axes(zo, 1)\nOffsetArrays.IdOffsetRange(values=1:4, indices=2:5)\n\njulia> Array(zo)\nERROR: BoundsError: attempt to access 4-element UnitRange{Int64} at index [5]\n[...]","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"The Array conversion errors despite zo having 1-based indices. The function axes(zo, 1) hints at the underlying problem –- the values and the indices of the axis are different. We may check that the axis of zo is not its own axis:","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"julia> axes(zo, 1)\nOffsetArrays.IdOffsetRange(values=1:4, indices=2:5)\n\njulia> axes(axes(zo, 1), 1)\nOffsetArrays.IdOffsetRange(values=2:5, indices=2:5)","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"In this case the bug may be fixed by defining the axes of a ZeroBasedRange to be idempotent, for example using the OffsetArrays.IdentityUnitRange wrapper:","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"julia> Base.axes(A::ZeroBasedRange) = map(x -> OffsetArrays.IdentityUnitRange(0:x-1), size(A.a))\n\njulia> axes(zo, 1)\nOffsetArrays.IdOffsetRange(values=1:4, indices=1:4)","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"With this new definition, the values and indices of the axis are identical, which makes indexing idempotent. The conversion to an Array works as expected now:","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"julia> Array(zo)\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4","category":"page"},{"location":"internals/#Caveats","page":"For developers","title":"Caveats","text":"","category":"section"},{"location":"internals/","page":"For developers","title":"For developers","text":"Because IdOffsetRange behaves quite differently to the normal UnitRange type, there are some cases that you should be aware of, especially when you are working with multi-dimensional arrays.","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"One such cases is getindex:","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"julia> Ao = zeros(-3:3, -3:3); Ao[:] .= 1:49;\n\njulia> Ao[-3:0, :] |> axes # the first dimension does not preserve offsets\n(OffsetArrays.IdOffsetRange(values=1:4, indices=1:4), OffsetArrays.IdOffsetRange(values=-3:3, indices=-3:3))\n\njulia> Ao[-3:0, -3:3] |> axes # neither dimensions preserve offsets\n(Base.OneTo(4), Base.OneTo(7))\n\njulia> Ao[axes(Ao)...] |> axes # offsets are preserved\n(OffsetArrays.IdOffsetRange(values=-3:3, indices=-3:3), OffsetArrays.IdOffsetRange(values=-3:3, indices=-3:3))\n\njulia> Ao[:] |> axes # This is linear indexing\n(Base.OneTo(49),)","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"Note that if you pass a UnitRange, the offsets in corresponding dimension will not be preserved. This might look weird at first, but since it follows the a[ax][i] == a[ax[i]] rule, it is not a bug.","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"julia> I = -3:0; # UnitRange always starts at index 1\n\njulia> Ao[I, 0][1] == Ao[I[1], 0]\ntrue\n\njulia> ax = axes(Ao, 1) # ax starts at index -3\nOffsetArrays.IdOffsetRange(values=-3:3, indices=-3:3)\n\njulia> Ao[ax, 0][1] == Ao[ax[1], 0]\ntrue","category":"page"},{"location":"internals/#Using-custom-axis-types","page":"For developers","title":"Using custom axis types","text":"","category":"section"},{"location":"internals/","page":"For developers","title":"For developers","text":"While a wide variety of AbstractUnitRanges provided by Base may be used as indices to construct an OffsetArray, at times it might be convenient to define custom types. The OffsetArray constructor accepts any type that may be converted to an AbstractUnitRange. This proceeds through a two-step process. Let's assume that the constructor called is OffsetArray(A, indstup), where indstup is a Tuple of indices.","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"At the first step, the constructor calls to_indices(A, axes(A), indstup) to lower indstup to a Tuple of AbstractUnitRanges. This step converts –- among other things –- Colons to axis ranges. Custom types may extend Base.to_indices(A, axes(A), indstup) with the desired conversion of indstup to Tuple{Vararg{AbstractUnitRange{Int}}} if this is feasible.\nAt the second step, the result obtained from the previous step treated again to convert it to a Tuple of AbstractUnitRanges to handle cases where the first step doesn't achieve this. An additional customization option may be specified at this stage: a type may be converted either to a single AbstractUnitRange{Int}, or to a Tuple of them. A type might specify which of these two behaviours is desired by extending OffsetArrays.AxisConversionStyle. An example of a type that is acted upon at this stage is CartesianIndices, which is converted to a Tuple of AbstractUnitRanges.","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"For example, here are a couple of custom type that facilitate zero-based indexing:","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"julia> struct ZeroBasedIndexing end\n\njulia> Base.to_indices(A, inds, ::Tuple{ZeroBasedIndexing}) = map(x -> 0:length(x)-1, inds)\n\njulia> a = zeros(3, 3);\n\njulia> oa = OffsetArray(a, ZeroBasedIndexing());\n\njulia> axes(oa)\n(OffsetArrays.IdOffsetRange(values=0:2, indices=0:2), OffsetArrays.IdOffsetRange(values=0:2, indices=0:2))","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"In this example we had to define the action of to_indices as the type ZeroBasedIndexing did not have a familiar hierarchy. Things are even simpler if we subtype AbstractUnitRange, in which case we need to define first and length for the custom range to be able to use it as an axis:","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"julia> struct ZeroTo <: AbstractUnitRange{Int}\n       n :: Int\n       ZeroTo(n) = new(n < 0 ? -1 : n)\n       end\n\njulia> Base.first(::ZeroTo) = 0\n\njulia> Base.length(r::ZeroTo) = r.n + 1\n\njulia> oa = OffsetArray(zeros(2,2), ZeroTo(1), ZeroTo(1));\n\njulia> axes(oa)\n(OffsetArrays.IdOffsetRange(values=0:1, indices=0:1), OffsetArrays.IdOffsetRange(values=0:1, indices=0:1))","category":"page"},{"location":"internals/","page":"For developers","title":"For developers","text":"Note that zero-based indexing may also be achieved using the pre-defined type OffsetArrays.Origin.","category":"page"}]
}
